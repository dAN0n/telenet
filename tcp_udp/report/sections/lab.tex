% !TEX root = ../TeleNet_Zobkov_435013.tex
\section{Реализация программы}

\subsubsection{Структура проекта}

При разработке приложения для операционной системы семейства Linux использовались текстовые редакторы Sublime Text 3 и Vim и компилятор g++.

При разработке приложения для операционной системы семейства Windows использовался текстовый редактор Sublime Text 3 и компилятор MinGW.

Язык программирования --- С++.

\subsubsection{Сетевая часть TCP}

Клиентское приложение в TCP только отсылает команды на сервер, поэтому оно ничем не отличается от telnet клиента. Сервер обрабатывает команды, работает с файлом, сохраняет и загружает свое состояние, присылает уведомления и т.д.

В первую очередь, на сервере происходит инициализация WinSock (на Windows), создание сокета (функция socket), привязка сокета к конкретному адресу (функция bind), подготовка сокета к принятию сообщений (функция listen). Реализация инициализации сервера представлена в \vref{app:createserver}.

После этого ожидаем подключения клиентов в бесконечном цикле с помощью функции accept. Если функция возвращает положительное значение, которое является клиентским сокетом, то создаем новый поток, в котором обрабатываем клиентские сообщения. Реализация подключения клиентов представлена в \vref{app:acceptconnections}. Структуры, используемые для работы с клиентами, представлены в \vref{app:struct}.

Клиентский поток вызывает функцию считывания символов в бесконечном цикле, как только при считывается знак перевода строки, функция возращает прочитанные символы. Если функция не вернула исключение, то посылаем команду на обработку, в противном случае это обозначает отключение клиента. Также отключение клиента может быть произведено извне обработчика клиентского потока, посредством закрытия клиентского сокета (функция считывания в этом случае сразу же вернет исключение) командой k <ID> или q. Реализация клиентского потока представлена в \vref{app:clientprocess}.

Функция считывания до символа перевода строки --- это оболочка для функции recv. Считывание происходит по одному символу и записывается в результирующую строку. Если соединение с клиентом разорвано, то функция возвращает исключение. Реализация функции считывания до символа перевода строки представлена в \vref{app:recvs}. Реализация закрытия сокета представлена в \vref{app:close}.

\subsubsection{Сетевая часть UDP}

Клиентское приложение в UDP не может быть заменено сторонним приложением по типу telnet, потому что используется нумерация пакетов, контроль команд и посылка ответов.

Реализация сетевой части UDP сервера похожа на TCP, за исключением следующих отличий:

\begin{itemize}
	\item Функция создания сокета выполняется с параметрами SOCK\_DGRAM, IPPROTO\_UDP;
	\item Отсутствует функция подготовки к принятию сообщений listen;
	\item Отсутствует функция установления соединения accept, вместо нее используется функция recvfrom и создание клиентского сокета функцией socket;
	\item Вместо функций send и recv используются функции sendto и recvfrom с явным указанием адресной структуры.
\end{itemize}

Реализации инициализации сервера и подключения новых клиентов представлены в \vrefrange{app:createserverudp}{app:acceptconnectionsudp}. Структура, используемая для работы с клиентами, представлены в \vref{app:structudp}.

Так как протокол UDP ненадежный и без установления соединения, некоторые пакеты могут затеряться в сети. Во избежание этого была реализована нумерация пакетов и посылка ответных пакетов. Для клиента каждое отправляемое сообщение соответствует следующей структуре:

\[\text{<PACKET\_ID>} ~ \text{<MESSAGE>}\]

После отправки данного сообщения, клиент в течение 2-х секунд ожидает ответа от сервера, после его получения отсылает сообщение о подтверждении получения данного ответа следующего формата:

\[\text{<PACKET\_ID>} ~ \text{\#CHECK}\]

Далее возможны следующии ситуации:

\begin{itemize}
	\item В случае если подтверждение не пришло, то будет выведено сообщение о том, что пакет <PACKET\_ID> был потерян;
	\item В случае если подтверждение пришло, но номер принятого пакета подтверждения не соответствует ожидаемому, будет выведено соответствующее сообщение.
\end{itemize}

Как только сервер получил от клиента сообщение, происходит проверка на дубликат или перемешивание <PACKET\_ID>, в случае если данная проверка подтверждается, то сервер пересылает клиенту сообщение о дубликате или перемешивании.

В случае если сообщение не является дубликатом или не тем пакетом, то сервер возвращает эхо-сообщение, с такой же структурой, которое было получено от клиента.

\section{Тестирование}

Тестирование проводилось на операционных системах Ubuntu Server 16.04 и Windows 10. Были проверены все команды, многопоточность, уведомления, UDP-пакеты, правильное завершение всех потоков.

\subsection{TCP}

\subsubsection{Запуск и выполнение команд}

\begin{lstlisting}[language=bash, caption=Лог сервера]
Server settings
Threads: 2
Port:    8080
Buffer:  8

Connection request received.
New socket was created at address 192.168.222.1:16115
l
Client list:
0|192.168.222.1:16115|
192.168.222.1:16115 login dan0n pass
l
Client list:
0|192.168.222.1:16115|dan0n
\end{lstlisting}

\begin{lstlisting}[language=bash, caption=Лог клиента]
Socket created
Connect success
Login or register new user (login/addusr LOGIN PASSWORD)
login dan0n pass
dan0n @ D:\4 course $

\end{lstlisting}

После запуска на стороне клиента вывелись сообщения об успешной инициализации. Далее с сервера было автоматически получено приветственное сообщение, с предложение авторизации или регистрации. Пользователем была введена команда авторизации, а также уже существующий логин и пароль. После успешной проверки введенного сообщения, сервер отправил путь текущей директории для данного пользователя.

На стороне сервера, были выведены сообщения об инициализации, затем после подключения клиента было выведено соответствующее сообщение. Также показано, как данный клиент отображается в списке до и после авторизации.

\subsubsection{Многопоточность}

\begin{lstlisting}[language=bash, caption=Лог сервера]
...
Connection request received.
New socket was created at address 192.168.222.1:18637
Connection request received.
New socket was created at address 192.168.222.1:21297
Connection request received.
New socket was created at address 192.168.222.1:22978
\end{lstlisting}

К серверу были подключены три клиента, два из них были подключены через написанный
клиент, а третий через telnet. Сервер и клиенты успешно функционировали.

\subsubsection{Отключение клиента}

\begin{lstlisting}[language=bash, caption=Лог сервера]
Server settings
Threads: 2
Port:    8080
Buffer:  8

Connection request received.
New socket was created at address 192.168.222.1:16115
l
Client list:
0|192.168.222.1:16115|
192.168.222.1:16115 login dan0n pass
l
Client list:
0|192.168.222.1:16115|dan0n
192.168.222.1:16115 was disconnected
\end{lstlisting}

\begin{lstlisting}[language=bash, caption=Лог клиента]
Socket created
Connect success
Login or register new user (login/addusr LOGIN PASSWORD)
login dan0n pass
dan0n @ D:\4 course $
quit
You are disconnected!
\end{lstlisting}

Клиент успешно подключился к серверу, затем процесс клиента был завершен. На сервере сразу же вывелось соответствующее сообщение об отключении, так как при очередной попытке считать данные из сокета возникла ошибка, и процесс закончился.

\subsubsection{Отключение клиента сервером}

\begin{lstlisting}[language=bash, caption=Лог сервера]
Server settings
Threads: 2
Port:    8080
Buffer:  8

Connection request received.
New socket was created at address 192.168.222.1:54521
k 0
192.168.222.1:54521 was disconnected
\end{lstlisting}

\begin{lstlisting}[language=bash, caption=Лог клиента]
Socket created
Connect success
Login or register new user (login/addusr LOGIN PASSWORD)
You are disconnected!
\end{lstlisting}

Клиент успешно подключился к серверу, на сервере этот клиент был отключен командой k 0. В клиенте было выведено сообщение о том, что он отключен.

\subsection{UDP}

\subsubsection{Запуск и выполнение команд}

\begin{lstlisting}[language=bash, caption=Лог сервера]
Server port: 8080

Add new client 127.0.0.1:14554
ID:0 checked
ID:0 checked
\end{lstlisting}

\begin{lstlisting}[language=bash, caption=Лог клиента]
Use phrase "quit" for exit
qwerty
Echo: qwerty

echo
Echo: echo
\end{lstlisting}

После отправления сообщения клиентом приходят эхо-ответы от сервера. На стороне сервера видно подключение клиента и сообщения о проверенных пакетах, дошедших до клиента.

\subsubsection{Многопоточность}

\begin{lstlisting}[language=bash, caption=Лог сервера]
Server port: 8080

Add new client 127.0.0.1:14554
ID:0 checked
ID:0 checked
Add new client 127.0.0.1:23532
ID:1 checked
ID:1 checked
l
Client list:
0|127.0.0.1:14554
1|127.0.0.1:23532

\end{lstlisting}

К серверу были подключены два клиента, команда l подтвердила их подключение и
вывела некоторую информацию о них.


\subsubsection{Перемешивание/повторение пакетов}

Проведем эксперимент. Заставим клиента постоянно повторять 3 и 4 пакеты и посмотрим на результат.

\begin{lstlisting}[language=bash, caption=Лог сервера]
Server port: 8080

Add new client 127.0.0.1:41436
ID:0 checked
ID:0 checked
ID:0 checked
ID:0 checked
ID:0 checked
ID:0 checked
ID:0 checked
ID:0 checked

\end{lstlisting}

\begin{lstlisting}[language=bash, caption=Лог клиента]
Use phrase "quit" for exit
1
Echo: 1

2
Echo: 2

3
Echo: 3

4
Echo: 4

3
PACKAGE 3 WAS LOST
RECEIVED: #MIXING
4
PACKAGE 4 WAS LOST
RECEIVED: #SAME
3
PACKAGE 3 WAS LOST
RECEIVED: #MIXING
4
PACKAGE 4 WAS LOST
RECEIVED: #SAME
\end{lstlisting}

Как можно заметить, при получении 3-го пакета после 4-го от сервера приходит сообщение о перемешивании пакетов, при повторной отправке 4-го пакета приходит сообщение о дублировании пакетов, так как ожидается 5-ый пакет.